<!doctype html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <title>Batman Playtest v7 ‚Äì pivots + hop + stabile skygger</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#0b0d11; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #error { position:fixed; inset:0; display:none; padding:16px; background:rgba(0,0,0,.85); z-index:9999; overflow:auto; }
    #error h3{margin:0 0 8px 0}
    #error pre{white-space:pre-wrap; word-break:break-word; background:#111; padding:12px; border:1px solid #333; border-radius:8px}
    .hud { position:fixed; inset:auto 12px 12px auto; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); padding:6px 10px; border-radius:10px; font-size:12px; }
    .topbadge { position:fixed; top:12px; right:12px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); padding:6px 10px; border-radius:10px; font-size:12px; }
  </style>
</head>
<body>
  <div class="hud" style="right:auto; left:12px; bottom:12px">
  <button id="toggleMusic">üéµ Musik</button>
  <input id="volMusic" type="range" min="0" max="1" step="0.01" value="0.7" />
  &nbsp;&nbsp;
  <button id="toggleSfx">üîä SFX</button>
  <input id="volSfx" type="range" min="0" max="1" step="0.01" value="0.9" />
</div>
  <div class="topbadge">Batman Playtest v7</div>
  <div class="hud">WASD / Piletaster: Bev√¶g ‚Ä¢ Shift: Sprint ‚Ä¢ <b>Space: Hop</b> ‚Ä¢ Mus: Orbit/Zoom</div>
  <div id="error"><h3>‚ö†Ô∏è Fejl</h3><div id="em"></div><pre id="es"></pre></div>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.160.0";
    import { OBJLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/OBJLoader.js";
    import { MTLLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/MTLLoader.js";
    import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ---------- fejl-overlay ----------
    const showErr = (msg, stack="")=>{
      const box = document.getElementById('error');
      document.getElementById('em').textContent = String(msg || "(ukendt fejl)");
      document.getElementById('es').textContent = String(stack || "");
      box.style.display = 'block';
      console.error("[Batman Playtest] ", msg, stack);
    };
    window.addEventListener('error', e => showErr(e.message, e.error?.stack));
    window.addEventListener('unhandledrejection', e => {
      const r = e.reason || {};
      showErr(r.message || r, r.stack);
    });

    // ---------- renderer/scene/cam ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x0b0d11, 1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 500);
    camera.position.set(0, 2.2, 6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 2.5;
    controls.maxDistance = 12;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.set(0, 1.0, 0);

    // lys + gulv
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(6, 12, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.bias = -0.0005;
    sun.shadow.normalBias = 0.02;
    const sc = sun.shadow.camera;
    sc.left = -80; sc.right = 80; sc.top = 80; sc.bottom = -80;
    sc.near = 0.1; sc.far = 120;
    scene.add(sun);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(200,200),
      new THREE.MeshStandardMaterial({ color:"#2a2f37", roughness:0.95 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    const grid = new THREE.GridHelper(200, 200, 0x3a4150, 0x232833);
    grid.position.y = 0.001;
    scene.add(grid);

    // ---------- input ----------
    const keys = new Map();
    const setKey = (e, down) => { keys.set(e.key.toLowerCase(), down); };
    addEventListener("keydown", e => setKey(e, true));
    addEventListener("keyup",   e => setKey(e, false));

    // hop: edge-detection for Space
    let spaceWasDown = false;
    const spaceDown = () => (keys.get(" ") || keys.get("space") || keys.get("spacebar"));

    // ---------- remap maps/ -> textures/ (og neutralis√©r bump) ----------
    const PIX1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
    THREE.DefaultLoadingManager.setURLModifier((url)=>{
      try { url = new URL(url, location.href).pathname; } catch {}
      if (url.includes("/maps/bump/")) return PIX1; // 1x1 png
      if (url.includes("/maps/"))      return url.replace("/maps/","/textures/");
      return url;
    });

    // ---------- load OBJ+MTL ----------
    const mtlLoader = new MTLLoader();
    mtlLoader.setResourcePath("assets/Batman/");

    // Batman root + noder
    const batmanRoot = new THREE.Group(); // global position/orientering (inkl. hop Y)
    scene.add(batmanRoot);

    // ret solens target til Batman for stabile skygger
    sun.target = batmanRoot;
    scene.add(sun.target);

    const hip = new THREE.Group();       // hofte (b√¶rer hele OBJ)
    hip.position.set(0, 0.0, 0);
    batmanRoot.add(hip);

    // meshes til ben/arme/h√¶nder
    let meshLegL=null, meshLegR=null, meshArmL=null, meshHandL=null, meshArmR=null, meshHandR=null;
    // pivot-grupper vi roterer
    let legPivotL=null, legPivotR=null, armPivotL=null, armPivotR=null;

    function pbrifyMaterials(mtl){
      Object.values(mtl.materials || {}).forEach(mat=>{
        mat.side = THREE.DoubleSide;
        if (mat.map) { mat.map.colorSpace = THREE.SRGBColorSpace; mat.map.needsUpdate = true; }
        if (mat.emissiveMap) { mat.emissiveMap.colorSpace = THREE.SRGBColorSpace; mat.emissiveMap.needsUpdate = true; }
      });
    }
    function setShadow(obj){
      obj.traverse(c=>{
        if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; }
      });
    }
    function findMeshes(obj){
      obj.traverse(node=>{
        if (!node.isMesh) return;
        const n = (node.name || "");
        if (n === "Part.6")  meshLegL  = node; // venstre ben
        if (n === "Part.7")  meshLegR  = node; // h√∏jre ben
        if (n === "Part.11") meshArmL  = node; // venstre arm
        if (n === "Part.12") meshHandL = node; // venstre h√•nd
        if (n === "Part.9")  meshArmR  = node; // h√∏jre arm
        if (n === "Part.10") meshHandR = node; // h√∏jre h√•nd
      });
      console.log("[Found]", {
        LegL: meshLegL?.name, LegR: meshLegR?.name,
        ArmL: meshArmL?.name, HandL: meshHandL?.name,
        ArmR: meshArmR?.name, HandR: meshHandR?.name
      });
    }

    // Opret pivot ved √∏verste punkt vha. WORLD-bbox, og placer pivot i PARENT-LOKALT rum.
    function makePivotAtTop_WorldBox(mesh, alsoAttach = [], inwardX = 0){
      if (!mesh) return null;
      const worldBox = new THREE.Box3().setFromObject(mesh);
      const topWorld = new THREE.Vector3(
        (worldBox.min.x + worldBox.max.x)/2,
        worldBox.max.y,
        (worldBox.min.z + worldBox.max.z)/2
      );
      const parent = mesh.parent;
      const pivot = new THREE.Group();
      parent.add(pivot);
      const topLocal = parent.worldToLocal(topWorld.clone());
      pivot.position.copy(topLocal);

      // lille indad-offset mod torso for naturligere akse
      if (inwardX !== 0){
        const torsoWorld = new THREE.Vector3();
        hip.getWorldPosition(torsoWorld);
        const meshWorld = new THREE.Vector3();
        mesh.getWorldPosition(meshWorld);
        const side = (meshWorld.x >= torsoWorld.x) ? 1 : -1;
        pivot.position.x += inwardX * side;
      }

      pivot.attach(mesh);
      for (const child of alsoAttach) { if (child) pivot.attach(child); }
      return pivot;
    }

    mtlLoader.load(
      "assets/Batman/Untitled Model.mtl",
      (mtl) => {
        try {
          mtl.preload();
          pbrifyMaterials(mtl);

          const objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          objLoader.load(
            "assets/Batman/Untitled Model.obj",
            (obj) => {
              try {
                setShadow(obj);

                // skaler til ~1.7 h√∏j
                let box = new THREE.Box3().setFromObject(obj);
                const size = new THREE.Vector3(); box.getSize(size);
                const scale = (size.y > 1e-4) ? (1.7 / size.y) : 1.0;
                obj.scale.setScalar(scale);

                // f√∏dder p√• gulv (model-lokal)
                box = new THREE.Box3().setFromObject(obj);
                obj.position.y += -box.min.y;

                // vend 180¬∞ (kigger v√¶k fra kameraet)
                obj.rotation.y = Math.PI;

                hip.add(obj);

                // find relevante meshes
                findMeshes(obj);

                // BYG PIVOTS (world-bbox ‚Üí parent-local), med let indad-offset
                legPivotL = makePivotAtTop_WorldBox(meshLegL, [], 0.02);
                legPivotR = makePivotAtTop_WorldBox(meshLegR, [], 0.02);
                armPivotL = makePivotAtTop_WorldBox(meshArmL, [meshHandL], 0.02);
                armPivotR = makePivotAtTop_WorldBox(meshArmR, [meshHandR], 0.02);

                console.log("[Batman] OBJ+MTL loaded OK (world-pivots built)");
              } catch (e) {
                showErr("Batman model post-process fejlede", e.stack);
              } finally {
                THREE.DefaultLoadingManager.setURLModifier(null);
              }
            },
            undefined,
            (err)=>{ showErr("OBJ kunne ikke indl√¶ses (tjek stier/filnavn).", String(err)); THREE.DefaultLoadingManager.setURLModifier(null); }
          );
        } catch (e) {
          showErr("MTL post-process fejlede", e.stack);
          THREE.DefaultLoadingManager.setURLModifier(null);
        }
      },
      undefined,
      (err)=>{ showErr("MTL kunne ikke indl√¶ses", String(err)); THREE.DefaultLoadingManager.setURLModifier(null); }
    );

    // ---------- bev√¶gelse + hop-fysik ----------
    const state = {
      pos: new THREE.Vector3(0, 0, 0), // x,z; y kontrolleres separat (hop)
      yaw: 0,
      vel: new THREE.Vector3(),
      speedWalk: 3.2,
      speedRun: 5.6,
      damping: 12.0,
      // hop
      y: 0,
      vy: 0,
      gravity: -18.0,
      jumpVel: 7.6,
      onGround: true,
      airTime: 0
    };

    function inputDir(){
      let f=0, s=0;
      if (keys.get("w") || keys.get("arrowup")) f += 1;
      if (keys.get("s") || keys.get("arrowdown")) f -= 1;
      if (keys.get("a") || keys.get("arrowleft")) s -= 1;
      if (keys.get("d") || keys.get("arrowright")) s += 1;
      const v = new THREE.Vector3(s, 0, -f);
      if (v.lengthSq()>0) v.normalize();
      // bev√¶gelse i forhold til kameraets yaw
      const camYaw = Math.atan2(camera.position.x - controls.target.x, camera.position.z - controls.target.z);
      v.applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);
      return v;
    }

    // ---------- animation (ben + hofte + arme) ----------
    let walkPhase = 0;

    function animateCharacter(dt, planarSpeed){
      const moving = planarSpeed > 0.08;
      const airborne = !state.onGround;

      // hofte-bob (ingen bob i luften)
      const bobAmp = 0.02; // d√¶mpet for mere "tung" f√∏lelse
      const bob = (!airborne && moving) ? Math.abs(Math.sin(walkPhase*1.6)) * bobAmp : 0.0;
      hip.position.y = THREE.MathUtils.lerp(hip.position.y, bob, 1 - Math.exp(-10 * dt));

      // -------- BEN (via pivots i hofterne) ----------
      let leftTargetX = 0, rightTargetX = 0;
      if (airborne) {
        const splayMax = 0.95;
        const nearGround = Math.min(1, Math.max(0, 1 - state.y / 0.6));
        const falling = state.vy < -0.1 ? 1 : 0;
        const gather = Math.min(1, (nearGround * 0.8 + falling * 0.2));
        const splay = splayMax * (1 - 0.85 * gather);
        leftTargetX  =  splay;
        rightTargetX = -splay;
      } else {
        const ampMax = 0.7;
        const amp = moving ? Math.min(1, planarSpeed / state.speedRun) * ampMax : 0.0;
        leftTargetX  = Math.sin(walkPhase) * amp;
        rightTargetX = -leftTargetX;
      }
      const kLeg = 1 - Math.exp(-16 * dt);
      if (legPivotL) legPivotL.rotation.x = THREE.MathUtils.lerp(legPivotL.rotation.x, leftTargetX,  kLeg);
      if (legPivotR) legPivotR.rotation.x = THREE.MathUtils.lerp(legPivotR.rotation.x, rightTargetX, kLeg);

      // -------- ARME (skulder-pivots; h√¶nder f√∏lger) ----------
      let armTargetX = 0;
      if (airborne) armTargetX = -1.05; // l√∏ft armene i hop
      const kArm = 1 - Math.exp(-14 * dt);
      if (armPivotL) armPivotL.rotation.x = THREE.MathUtils.lerp(armPivotL.rotation.x, armTargetX, kArm);
      if (armPivotR) armPivotR.rotation.x = THREE.MathUtils.lerp(armPivotR.rotation.x, armTargetX, kArm);

      // opdat√©r gang-fasen kun p√• jorden
      if (!airborne) {
        const baseFreq = (moving ? 8.5 : 6.0);
        const speedFactor = 0.7 + 0.3 * Math.min(1, planarSpeed / state.speedRun);
        walkPhase += baseFreq * speedFactor * dt;
      }
    }

    // ---------- main loop ----------
    const clock = new THREE.Clock();
    (function loop(){
      const dt = Math.min(clock.getDelta(), 1/30);

      const dir = inputDir();
      const maxSpeed = (keys.get("shift") || keys.get("shiftleft") || keys.get("shiftright")) ? state.speedRun : state.speedWalk;

      // acceleration/d√¶mpning
      state.vel.x = THREE.MathUtils.lerp(state.vel.x, dir.x * maxSpeed, 1 - Math.exp(-state.damping * dt));
      state.vel.z = THREE.MathUtils.lerp(state.vel.z, dir.z * maxSpeed, 1 - Math.exp(-state.damping * dt));

      // opdater position
      state.pos.x += state.vel.x * dt;
      state.pos.z += state.vel.z * dt;

      // hop input
      const sd = !!spaceDown();
      if (sd && !spaceWasDown && state.onGround) {
        state.vy = state.jumpVel;
        state.onGround = false;
        state.airTime = 0;
      }
      spaceWasDown = sd;

      // vertikal fysik
      if (!state.onGround) {
        state.vy += state.gravity * dt;
        state.y  += state.vy * dt;
        state.airTime += dt;

        if (state.y <= 0) {
          state.y = 0;
          state.vy = 0;
          state.onGround = true;
        }
      }

      // vend figur i bev√¶gelsesretning
      const planarSpeed = Math.hypot(state.vel.x, state.vel.z);
      if (planarSpeed > 0.2) {
        const lookYaw = Math.atan2(-state.vel.x, -state.vel.z);
        const wrap = (a)=>Math.atan2(Math.sin(a), Math.cos(a));
        let dy = wrap(lookYaw - state.yaw);
        state.yaw = state.yaw + dy * Math.min(1, dt*10);
      }

      // placer batman (inkl. y fra hop)
      batmanRoot.position.set(state.pos.x, state.y, state.pos.z);
      batmanRoot.rotation.y = state.yaw;

      // animationer
      animateCharacter(dt, planarSpeed);

      // OrbitControls target f√∏lger Batman
      controls.target.set(state.pos.x, 1.0 + state.y, state.pos.z);
      controls.update();

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    })();

    // ---------- resize ----------
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
